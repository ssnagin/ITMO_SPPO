# Конспект лекций по Лабораторной работе №3

## Организация одномерных массивов в памяти БЭВМ

Одномерные массивы в БЭВМ могут быть представлены по-разному, всё ограничивается способностями программиста и ресурсами БЭВМ. 

Например, каждое значение массива хранится в каждой ячейке памяти, при этом доступ к каждой из ячеек происходит за счёт автоинкрементной (декрементной) адрессации.

![](img/Pasted%20image%2020250310160318.png)

В данном примере `0x000` -- размер массива, `0x001` -- текущий адрес ячейки массива. **Обратите внимание** что это лишь пример, а не часть готовой программы. Нужно выделить место для данных и самой программы, а так же, при надобности, добавить счетчик перибора ячеек или ещё что-то.

![](img/Pasted%20image%2020250310160842.png)

Элементы массива могут занимать меньше или больше памяти. В идеале размер таких данных должен быть кратен 16, так как иначе стоит создавать в программе упаковщик/декомпановщик данных, что влечёт дополнительные мощностные расходы.


### Организация и обработка числовых массивов с числом измерений больше, чем одно

[тут](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays#multidimensional-arrays) взять инфу

## Сравнение числовых значений

Давайте для начала подумаем: как бы мы стали сравнивать 2 числа без использования знаков сравнения? Ответ ниже

```
A ? B       Вычтем из обоих частей B:
A - B ? B - B
A - B ? 0
```

Нужно вычесть из одного числа другое, и флаги по результату операции подскажут, какое число больше/меньше или равно.

Традиционно для подобных махинаций есть команда `CMP 0xMMM`: одна вычитает из AC число, расположенное по адресу `0xMMM`, но в отличие от `SUB` не записывает результат в аккумулятор, а только выставляет флаги по операции. Это экономит нам целый один (!) регистр AC.

Не всегда можно её использовать: подойдет любая программа, которая выставляет флаги по результатам операции.

Вот как это написано в методичке:

![](img/Pasted%20image%2020250310181459.png)

### Команды условных и безусловного перехода

![](img/Pasted%20image%2020250310182705.png)

`F0XX - F5XX и CEXX` Команды безусловного перехода
`F5XX - F9XX и CEXX` Команды безусловного перехода
## Организация цисклических вычислений

![](img/Pasted%20image%2020250310184915.png)

Подробнее рассмотрим команду LOOP:

### Команда LOOP

Нужна для создания циклов с счетчиком. Команда уменьшает заданную ячейку памяти, определяющую число повторений, и проверяет, что в ячейке ещё находится положительное число. Если да, то выполняется следующая команда после LOOP (как правило JUMP); если число <= 0, то к счетчику команд добавляется единица, и следующей будет выполнена команда через одну после LOOP.

LOOP не работает с флагами и имеет адрес `0x8MMM`.

Пример использования JUMP + LOOP: функция `R = 50Y`:

![](img/Pasted%20image%2020250310185416.png)

#### Полный цикл команды LOOP:

Рассмотрим полный цикл команды LOOP на примере этой же программы.

##### 1. Instruction Fetch

Тут всё по старинке, но для профилактики ещё раз распишу:

![](img/Pasted%20image%2020250310192220.png)

Проверка флагов перед работой (пока это необязательно)

![](img/Pasted%20image%2020250310192254.png)

на подъеме: `IP -> ALU`

на спаде: `ALU -> AR` и `ALU -> BR`, чтобы следующим тактом инкрементировать `IP`.

![](img/Pasted%20image%2020250310192605.png)

на подъеме: `BR -> ALU` и `MEM(AR)`

на спаде: `MEM(AR) -> DR` и `ALU -> IP + 1`

Из-за особенностей ЭВМ выборка значения из памяти и сложение с `ALU` происходят одновременно. Сплошная экономия!

![](img/Pasted%20image%2020250310193049.png)

на подъеме: `DR -> ALU`

на спаде: `ALU -> CR`

Передаем команду из `DR`.

Далее `CR -> ...` см. микрокод

##### 2. Operand Fetch

Напоминаю, что адресация прямая абсолютная, address fetch скипается

![](img/Pasted%20image%2020250310193608.png)

`DR -> AR`

![](img/Pasted%20image%2020250310193656.png)

##### 3. Execution

![](img/Pasted%20image%2020250310193828.png)

После **Operand Fetch** `DR` содержит значение операнда

Здесь БЭВМ читает команду

![](img/Pasted%20image%2020250310193950.png)

Вычитаем единицу из DR: `~0 + DR -> DR ; neg(0x0) = 0xFFFF = -1`

![](img/Pasted%20image%2020250310194646.png)

Записываем значение операнда в память и попутно вычитаем единицу из DR и сохраняем в BR (передадим значение в след. такте)

**Зачем мы вычитаем единицу!?** Обратимся к микрокоду:

`if BR(15) = 0 then GOTO INT @ C4`

Всё ещё непонятно? Ничего, я тоже не сразу понял. Предположим у вас вначале в счетчике цикла было значение 1. БЭВМ вычил единицу, записал 0 в ячейку с счетчиком, т.е. всё, она равна нулю, больше крутить LOOP не надо. Что происходит когда мы вычитаем ещё единицу? Вот эта картина:

![](img/Pasted%20image%2020250310200132.png)

Нам даже не нужны флаги, чтобы проверить отрицание (напоминаю, команда LOOP ***никак*** не трогает флаги)

1. Если BR отрицательный (15й бит равен 1), то IP + 1 и конец цикла исполнения команды LOOP
2. Если BR положительный, то сразу наступает конец цикла исполнения команды LOOP.

![](img/Pasted%20image%2020250310195825.png)

### Команда JUMP

Не менее полезным будет рассмотреть команду JUMP. Она очень простая: записывает в `IP` адрес следующей команды для выполнения.
JUMP, как и LOOP, вообще не трогает флаги
Адрес команды: `0xCMMM`.

#### Полный цикл исполнения команды LOOP:

Программа начинается с того, что на этапе микрокода `25` мы прыгаем в `4A`:

![](img/Pasted%20image%2020250310202011.png)

Там происходят всякие проверки, можете сами посмотреть. 

Записываем `DR -> IP` и всё. Причем тут работает магия: значение команды не записывается в IP из-за ограничения размера битов, (`0x7FF` это максимальный адрес ячейки памяти).

![](img/Pasted%20image%2020250310202159.png)

## Режимы адрессации БЭВМ



На протяжении истории первой и второй БЭВМ количество режимов адресации менялось с 2 до 7. Добавились косвенные, но при этом пожертвовали косвенной абсолютной из-за ограничений БЭВМ-2. Подробнее об этом написано в [конспекте микролекции](../../../microlectures/TYPES_OF_ADDRESSING.md).

**Зачем они нужны?** Для удобства. Чтобы программа не зависела от конкретных адресов ячеек памяти, т.е. чтобы её можно было свободно перемещать внутри памяти, а так же для экономии регистров, флагов и времени выполнения.

### Список
#### Прямая абсолютная 

11 бит: `0..7` 


### Как запомнить режимы адрессации без боли?

Для этого необходимо понимать, а что вообще внутри происходит. В [таблице](../../IMPORTANT_TABLES.md) где "Циклы выборки адресов для различных видов адресации" к описанию написаны ещё машинные циклы. Давайте разберем, что там что делает.

Для того, чтобы прочитать ячейку памяти, нужен адрес. Что если адреса нет? Значит, его нужно достать! Во всех командах в AF и OF происходит как минимум ***1*** обращение к памяти. 

Затруднение может вызвать строка `SXT_CR(0..7) -> BR`. Это команда расширения 7 (старшего) бита из CR. Она появляется только тогда, когда адрессация относительная и нужна чтобы "перемещаться" по памяти вверх и вниз относительно IP. 

| 15..8 | 7   | 6   | 5   | 4   | 3   | 2   | 1   | куда |
| ----- | --- | --- | --- | --- | --- | --- | --- | ---- |
| **1** | *1* | X   | X   | X   | X   | X   | X   | ⬆️   |
| **0** | *0* | X   | X   | X   | X   | X   | X   | 🔻   |

Как-нибудь подробнее я распишу здесь как это происходит.

### Описание адресных команд и команд переходов с различными режимами адрессации

[Важные таблицы по БЭВМ-2](../../IMPORTANT_TABLES.md)

### Количество обращений к памяти команд БЭВМ с различными режимами адрессации

Зависит от команды, но в целом, формула проста:

`I = 1 + N + M` - Общее кол-во вызовов = кол-во вызовов в Instruction Fetch (1) + (Address fetch и Operand Fetch) + Execution.

Цикл команды всегда будет использовать ***не менее 1 обращения к памяти***. 

#### Небольшая шпаргалка

| адресация                                        | кол-во обращений к MEM |
| ------------------------------------------------ | ---------------------- |
| Прямая ABS и прямая относительная<br>`0-7` и `E` | 1                      |
| Косв со смещением SP<br>`C`                      | 1                      |
| Косв. относительная (IP)<br>`8`                  | 2                      |
| Косв. авто inc / dec<br>`A` и `B`                | 3                      |
| Прямая загрузка операнда<br>`F`                  | сами подумайте 😏      |

| команда  | кол-во обращений к MEM |
| -------- | ---------------------- |
| **LOOP** | 1                      |
| **JUMP** | 0                      |
| **CALL** | 1                      |
|          |                        |
|          |                        |

Для остальных команд смотрите микрокод, там явно написано.

На примере `DADA`: это команда `CALL (26)+`, косвенная автоинкрементная адресация.
Тогда кол-во обращений: `1 + 3 + 1 = 5`

### Месторасположение аргументов и результата программы

Зависит от вашей программы. В целом, из варианта в вариант относительное расположение этих данных не меняется

### Максимально возможное кол-во поддерживаемых элементов данных в программе

127