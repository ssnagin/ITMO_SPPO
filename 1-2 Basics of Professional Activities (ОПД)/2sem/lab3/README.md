# Конспект лекций по Лабораторной работе №3

## Организация одномерных массивов в памяти БЭВМ

Одномерные массивы в БЭВМ могут быть представлены по-разному, всё ограничивается способностями программиста и ресурсами БЭВМ. 

Например, каждое значение массива хранится в каждой ячейке памяти, при этом доступ к каждой из ячеек происходит за счёт автоинкрементной (декрементной) адрессации.

![](img/Pasted%20image%2020250310160318.png)

В данном примере `0x000` -- размер массива, `0x001` -- текущий адрес ячейки массива. **Обратите внимание** что это лишь пример, а не часть готовой программы. Нужно выделить место для данных и самой программы, а так же, при надобности, добавить счетчик перибора ячеек или ещё что-то.

![](img/Pasted%20image%2020250310160842.png)

Элементы массива могут занимать меньше или больше памяти. В идеале размер таких данных должен быть кратен 16, так как иначе стоит создавать в программе упаковщик/декомпановщик данных, что влечёт дополнительные мощностные расходы.


### Организация и обработка числовых массивов с числом измерений больше, чем одно

[тут](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays#multidimensional-arrays) взять инфу

## Сравнение числовых значений

Давайте для начала подумаем: как бы мы стали сравнивать 2 числа без использования знаков сравнения? Ответ ниже

```
A ? B       Вычтем из обоих частей B:
A - B ? B - B
A - B ? 0
```

Нужно вычесть из одного числа другое, и флаги по результату операции подскажут, какое число больше/меньше или равно.

Традиционно для подобных махинаций есть команда `CMP 0xMMM`: одна вычитает из AC число, расположенное по адресу `0xMMM`, но в отличие от `SUB` не записывает результат в аккумулятор, а только выставляет флаги по операции. Это экономит нам целый один (!) регистр AC.

Не всегда можно её использовать: подойдет любая программа, которая выставляет флаги по результатам операции.

Вот как это написано в методичке:

![](img/Pasted%20image%2020250310181459.png)

### Команды условных и безусловного перехода

![](img/Pasted%20image%2020250310182705.png)

`F0XX - F5XX и CEXX` Команды безусловного перехода
`F5XX - F9XX и CEXX` Команды безусловного перехода
## Организация цисклических вычислений

![](img/Pasted%20image%2020250310184915.png)

Подробнее рассмотрим команду LOOP:

### Команда LOOP

Нужна для создания циклов с счетчиком. Команда уменьшает заданную ячейку памяти, определяющую число повторений, и проверяет, что в ячейке ещё находится положительное число. Если да, то выполняется следующая команда после LOOP (как правило JUMP); если число <= 0, то к счетчику команд добавляется единица, и следующей будет выполнена команда через одну после LOOP.

LOOP не работает с флагами и имеет адрес `0x8MMM`.

Пример использования JUMP + LOOP: функция `R = 50Y`:

![](img/Pasted%20image%2020250310185416.png)

#### Полный цикл команды LOOP:

Рассмотрим полный цикл команды LOOP на примере этой же программы.

##### 1. Instruction Fetch

Тут всё по старинке, но для профилактики ещё раз распишу:

![](img/Pasted%20image%2020250310192220.png)

Проверка флагов перед работой (пока это необязательно)

![](img/Pasted%20image%2020250310192254.png)

на подъеме: `IP -> ALU`
на спаде: `ALU -> AR` и `ALU -> BR`, чтобы следующим тактом инкрементировать `IP`.

![](img/Pasted%20image%2020250310192605.png)

на подъеме: `BR -> ALU` и `MEM(AR)`
на спаде: `MEM(AR) -> DR` и `ALU -> IP + 1`

Из-за особенностей ЭВМ выборка значения из памяти и сложение с `ALU` происходят одновременно. Сплошная экономия!

![](img/Pasted%20image%2020250310193049.png)

на подъеме: `DR -> ALU`
на спаде: `ALU -> CR`

Передаем команду из `DR`.

Далее `CR -> ...` см. микрокод

##### 2. Operand Fetch

Не забываем, что адрессация косвенная относительная:

![](img/Pasted%20image%2020250310193608.png)

`DR -> AR`

![](img/Pasted%20image%2020250310193656.png)

##### 3. Execution

![](img/Pasted%20image%2020250310193828.png)

После **Operand Fetch** `DR` содержит значение операнда
Здесь БЭВМ читает команду

![](img/Pasted%20image%2020250310193950.png)

Вычитаем единицу из DR: `~0 + DR -> DR ; neg(0x0) = 0xFFFF = -1`

![](img/Pasted%20image%2020250310194646.png)

Записываем значение операнда в память и попутно вычитаем единицу из DR и сохраняем в BR (передадим значение в след. такте)

**Зачем мы вычитаем единицу!?** Обратимся к микрокоду:

`if BR(15) = 0 then GOTO INT @ C4`

Всё ещё непонятно? Ничего, я тоже не сразу понял. Предположим у вас вначале в счетчике цикла было значение 1. БЭВМ вычил единицу, записал 0 в ячейку с счетчиком, т.е. всё, она равна нулю, больше крутить LOOP не надо. Что происходит когда мы вычитаем ещё единицу? Вот эта картина:

![](img/Pasted%20image%2020250310200132.png)

Нам даже не нужны флаги, чтобы проверить отрицание (напоминаю, команда LOOP ***никак*** не трогает флаги)

1. Если BR отрицательный (15й бит равен 1), то IP + 1 и конец цикла исполнения команды LOOP
2. Если BR положительный, то сразу наступает конец цикла исполнения команды LOOP.



![](img/Pasted%20image%2020250310195825.png)


### Команда JUMP

Не менее полезным будет рассмотреть команду JUMP. Она очень простая: записывает в `IP` адрес следующей команды для выполнения.
JUMP, как и LOOP, вообще не трогает флаги
Адрес команды: `0xCMMM`.

#### Полный цикл исполнения команды LOOP:

Программа начинается с того, что на этапе микрокода `25` мы прыгаем в `4A`:

![](img/Pasted%20image%2020250310202011.png)

Там происходят всякие проверки, можете сами посмотреть. 

Записываем `DR -> IP` и всё. Причем тут работает магия: значение команды не записывается в IP из-за ограничения размера битов, (`0x7FF` это максимальный адрес ячейки памяти).

![](img/Pasted%20image%2020250310202159.png)

## Режимы адрессации БЭВМ

Дополнить

### Описание адресных команд и команд переходов с различными режимами адрессации



### Количество обращений к памяти команд БЭВМ с различными режимами адрессации



### Месторасположение аргументов и результата программы

### Максимально возможное кол-во поддерживаемых элементов данных в программе



