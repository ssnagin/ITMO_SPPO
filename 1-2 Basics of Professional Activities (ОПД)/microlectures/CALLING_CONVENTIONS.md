# Calling Conventions: Соглашения о вызовах функций

## Основные понятия

Когда программисты писали код исключительно на ассемблере, проблем с вызовом функций не существовало. Однако с появлением библиотек возникла необходимость в стандартизации способов вызова функций, чтобы обеспечить их совместимость.

**Проблемный пример**:  
Рассмотрим функцию возведения в степень:

```c
int pow(int base, int exp);
```

Разные программисты могли реализовать её по-разному:

```c
int pow(int exp, int base);  // Аргументы в обратном порядке
```

Для решения этой проблемы были разработаны **Calling Conventions** (соглашения о вызовах), которые регламентируют:

1. **Порядок передачи аргументов**
    - Направление (слева направо или справа налево)
    - Способ передачи (через стек или регистры)
2. **Возвращаемое значение**
    - Место размещения результата
    - Обработка составных типов (агрегатов)
3. **Очистка стека (Cleanup)**
    - Кто отвечает за освобождение аргументов - вызывающая или вызываемая функция

## Пример функции

```c
int pow(int base, int exp) {
    int result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
    }
    return result;
}
```

Основная идея соглашений о вызовах - создание "кубиков" (функций), которые можно вызывать, не зная их внутренней реализации, но зная их прототип.

## Основные типы Calling Conventions

Существует множество соглашений, зависящих от архитектуры процессора (набора регистров). Наиболее распространенные:

|  Соглашение  |                Описание                |        Использование         |
| :----------: | :------------------------------------: | :--------------------------: |
|  `stdcall`   |          Соглашение Microsoft          |         Windows API          |
|   `cdecl`    |        Стандартное для языка C         |         Unix-системы         |
|  `fastcall`  | Оптимизированное (использует регистры) |      Внутренние функции      |
|  `thiscall`  |        Для методов классов C++         | Объектно-ориентированный код |
| `vectorcall` |      Для работы с SIMD-векторами       |     Операции с векторами     |

**Особенность `thiscall`**: передача указателя `this` в регистр.

## Подробнее о cdecl и stdcall

### cdecl (C Declaration)

- **Аргументы**: передаются через стек в **обратном порядке** (справа налево)
- **Возвращаемое значение**: в регистре
- **Очистка стека**: выполняет вызывающая функция

Пример для varargs:

```c
int printf(char* format, ...);  // format будет на вершине стека
```

### stdcall (Standard Call)

- **Аргументы**: аналогично cdecl (обратный порядок)
- **Возвращаемое значение**: в регистре
- **Очистка стека**: выполняет вызываемая функция

## Практическая реализация на БЭВМ

Рассмотрим реализацию функции `pow` на ассемблере БЭВМ с использованием соглашения cdecl.

### Структура стека

```
EXP    4 ^
base   3 |
RET    2 |
RESULT 1 |
i      0 |
```

### Код функции

```asm
FPOW: 
    PUSH    ; Пролог
    PUSH    ; Резервируем место под локальные переменные
    
    LD #1
    ST &1    ; result = 1
    CLA
    ST &0    ; i = 0
    
LOOP:
    LD &0
    CMP &4
    BGE EXIT  ; if i >= exp -> exit

    ; Вызов функции умножения (пример вложенного вызова)
    PUSH     ; Аргумент b
    PUSH     ; Аргумент a
    
    LD &5    ; base
    ST &1    ; Аргумент b
    LD &3    ; result
    ST &0    ; Аргумент a
    CALL MUL
    
    SWAP     ; Очистка аргументов
    POP
    SWAP
    POP
    
    ST &1    ; result = mul(result, base)
    LD &0
    INC
    ST &0    ; i++
    
    JUMP LOOP

EXIT:
    LD &1    ; Загружаем результат в AC
    
    ; Эпилог - очистка локальных переменных
    SWAP
    POP
    SWAP
    POP
    
    RET      ; Возврат из функции
```

### Особенности реализации для stdcall

Основное отличие - очистка аргументов выполняется в вызываемой функции. Эпилог будет выглядеть сложнее:

```asm
    ; ... тело функции аналогично ...
    
    SWAP
    POP
    SWAP
    POP
    SWAP
    ST &2    ; Особенность stdcall
    SWAP
    SWAP
    POP
    SWAP
    POP
```

## Проблемы и решения

1. **32-битные значения**: на 16-битной БЭВМ требуют использования двух ячеек памяти
2. **Сохранение регистров**: необходимо учитывать, какие регистры сохраняет вызываемая функция
3. **Рекурсивные вызовы**: требуют аккуратной работы со стеком