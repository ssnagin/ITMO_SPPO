import numpy as np
from PIL import Image
import math

# === КОНСТАНТЫ СЕТКИ И ВИЗУАЛИЗАЦИИ ===
SIZE = 1001  # Размер сетки N x N (нечетное число для центра)
MAX_DEPTH = 6  # Максимальная глубина рекурсии (около 6-7 уже дают хороший фрактал)
PIXEL_GRID = np.zeros((SIZE, SIZE, 3), dtype=np.uint8)  # Сетка RGB
CENTER = SIZE // 2


# === ГЕОМЕТРИЧЕСКИЕ ФУНКЦИИ (Теорема Декарта и Содди) ===

def find_new_curvatures(k1, k2, k3):
    """Вычисляет кривизны двух окружностей, касающихся трех заданных."""
    try:
        radicand = k1 * k2 + k2 * k3 + k3 * k1
        # Избегаем math.sqrt для отрицательных значений, которые могут
        # возникнуть из-за ошибок округления, когда значение очень близко к 0.
        root = math.sqrt(max(0, radicand))

        sum_k = k1 + k2 + k3

        # Теорема Декарта: k_новая = sum_k ± 2*sqrt(k1*k2 + k2*k3 + k3*k1)
        k_plus = sum_k + 2 * root
        k_minus = sum_k - 2 * root

        return k_plus, k_minus
    except ValueError:
        # Может произойти, если radicand отрицательный (ошибка округления)
        return k1 + k2 + k3, k1 + k2 + k3


def find_new_center(k1, k2, k3, z1, z2, z3, k_new):
    """
    Вычисляет центр z_new (комплексное число) новой окружности по Формуле Содди.
    z_i - центр окружности i как комплексное число (x + iy)
    """

    # Расширенная Теорема Декарта (Формула Содди)
    # k_новая*z_новая = k1*z1 + k2*z2 + k3*z3 ± 2*sqrt(k1*z1*k2*z2 + k2*z2*k3*z3 + k3*z3*k1*z1)

    # Вычисляем члены под квадратным корнем
    term_1 = k1 * z1 * k2 * z2
    term_2 = k2 * z2 * k3 * z3
    term_3 = k3 * z3 * k1 * z1

    sum_terms = term_1 + term_2 + term_3

    # Комплексный квадратный корень
    root_val = csqrt(sum_terms)

    sum_kz = k1 * z1 + k2 * z2 + k3 * z3

    # Два решения для центра:
    z_plus = (sum_kz + 2 * root_val) / k_new
    z_minus = (sum_kz - 2 * root_val) / k_new

    return z_plus, z_minus


def csqrt(z):
    """Вычисление комплексного квадратного корня"""
    r = abs(z)
    phi = np.angle(z)
    return math.sqrt(r) * (math.cos(phi / 2) + 1j * math.sin(phi / 2))


# === ФУНКЦИЯ РЕКУРСИИ ===

def apollonian_gasket_recursive(k1, k2, k3, z1, z2, z3, depth, color):
    """
    Рекурсивная функция для построения ковра Аполлония.
    kX: кривизна окружности X
    zX: центр окружности X (комплексное число)
    depth: текущая глубина рекурсии
    color: цвет для текущей итерации
    """
    if depth >= MAX_DEPTH:
        return

    # 1. Находим две новые кривизны
    k_plus, k_minus = find_new_curvatures(k1, k2, k3)

    # Нас интересует только та окружность, которая меньше (имеет большую кривизну)
    # В контексте ограничивающей окружности C0, k_new должна быть той, которая
    # находится внутри области, заданной C0, C1, C2.
    # Если все k1, k2, k3 положительны, берем большую k_new (k_plus).
    if k1 > 0 and k2 > 0 and k3 > 0:
        k_new = k_plus
    # Если одна из них k1 отрицательна (это C0), k_new — это k_plus,
    # которая заполняет промежуток.
    elif k1 < 0 or k2 < 0 or k3 < 0:
        # Для фрактала, ограниченного C0, мы выбираем k_new,
        # которая находится в "нужном" промежутке.
        k_new = k_plus
    else:
        return

    # Проверка на вырожденный случай (линия или слишком большая окружность)
    if k_new <= 0.01:
        return

    # 2. Находим два центра для k_new
    z_plus, z_minus = find_new_center(k1, k2, k3, z1, z2, z3, k_new)

    # 3. Выбираем правильный центр
    # Здесь мы используем простую эвристику: выбираем центр, который находится ближе
    # к "среднему" центру (z1+z2+z3)/3. Это эвристика, в реальных приложениях
    # лучше использовать более строгий критерий, основанный на расположении.
    avg_z = (z1 + z2 + z3) / 3
    if abs(z_plus - avg_z) < abs(z_minus - avg_z):
        z_new = z_plus
    else:
        z_new = z_minus

    # === ВИЗУАЛИЗАЦИЯ (ЗАКРАШИВАНИЕ ЦЕНТРА) ===
    x_new, y_new = z_new.real, z_new.imag

    # Масштабирование и преобразование координат (от -1..1 до 0..SIZE)
    # Предполагаем, что фрактал умещается в квадрате от -1 до 1.
    scale = CENTER * 0.95  # Коэффициент масштаба
    pixel_x = int(CENTER + x_new * scale)
    pixel_y = int(CENTER - y_new * scale)  # Инвертируем Y для соответствия матрице

    if 0 <= pixel_x < SIZE and 0 <= pixel_y < SIZE:
        # Закрашиваем точку центра
        PIXEL_GRID[pixel_y, pixel_x] = color

        # Также закрасим область окружности для лучшей визуализации (опционально)
        r_new = 1.0 / k_new
        r_pix = int(r_new * scale)

        # Очень грубая отрисовка круга: закрашиваем квадрат вокруг центра
        for dy in range(-max(1, r_pix // 2), max(2, r_pix // 2)):
            for dx in range(-max(1, r_pix // 2), max(2, r_pix // 2)):
                px, py = pixel_x + dx, pixel_y + dy
                if 0 <= px < SIZE and 0 <= py < SIZE:
                    # Закрашиваем белым цветом, если это не центральная точка
                    if PIXEL_GRID[py, px].sum() == 0:
                        PIXEL_GRID[py, px] = [255, 255, 255]

    # === 4. РЕКУРСИВНЫЕ ВЫЗОВЫ ===

    # Переход к следующей глубине и новому цвету
    next_depth = depth + 1

    # Изменяем цвет (для визуализации итераций)
    next_color = [color[0], color[1], (color[2] + 40) % 255]

    # Новые тройки для рекурсии:

    # 1. Тройка (k1, k2, k_new)
    apollonian_gasket_recursive(k1, k2, k_new, z1, z2, z_new, next_depth, next_color)

    # 2. Тройка (k1, k3, k_new)
    apollonian_gasket_recursive(k1, k_new, k3, z1, z_new, z3, next_depth, next_color)

    # 3. Тройка (k2, k3, k_new)
    apollonian_gasket_recursive(k_new, k2, k3, z_new, z2, z3, next_depth, next_color)


def main():
    # === НАЧАЛЬНЫЕ УСЛОВИЯ (Ковер Аполлония с 4-мя касающимися окружностями) ===

    # Начнем с четырех попарно касающихся окружностей, где C0 - внешняя

    # C0: Ограничивающая окружность (радиус 1, кривизна -1, центр 0)
    k0 = -1.0
    z0 = complex(0.0, 0.0)

    # C1, C2, C3: Три равные внутренние окружности
    # Они должны касаться друг друга и C0
    k1 = 2 + math.sqrt(3)  # Кривизна
    r1 = 1.0 / k1

    # Для симметрии: центры должны образовывать равносторонний треугольник
    # x = r1, y = 0
    z1 = complex(r1, 0.0)
    # x = r1 * cos(120), y = r1 * sin(120)
    z2 = complex(r1 * math.cos(2 * math.pi / 3), r1 * math.sin(2 * math.pi / 3))
    # x = r1 * cos(240), y = r1 * sin(240)
    z3 = complex(r1 * math.cos(4 * math.pi / 3), r1 * math.sin(4 * math.pi / 3))

    # Скорректируем кривизны для упрощения: возьмем классические
    # C0: k=-1; C1, C2, C3: k=3. Это проще для начальной тройки, но центры будут другими!
    k0 = -1.0
    k_in = 3.0

    # Центры для k=-1, k=3, k=3, k=3: 
    # C0: k=-1, z=(0,0)
    # C1: k=3, z=(-1/3, 0)
    # C2: k=3, z=(1/3, 0)
    # C3: k=3, z=(0, 2*sqrt(3)/3) - но это не симметричная тройка в центре!

    # Используем симметричный набор:
    k0 = -1.0
    k1, k2, k3 = 3.0, 3.0, 3.0
    z0 = complex(0.0, 0.0)

    # Центры для трех равных окружностей (радиус 1/3)
    # C1, C2, C3 не могут касаться друг друга и C0 в центре, как описано выше.
    # Поэтому мы используем тройки, которые образуют "пространство" для заполнения.

    # Рекурсия вызывается для четырех начальных промежутков:

    # 1. Промежуток (C0, C1, C2) - заполняет пространство между C0, C1, C2
    apollonian_gasket_recursive(k0, k1, k2, z0, z1, z2, 0, [255, 0, 0])

    # 2. Промежуток (C0, C2, C3)
    apollonian_gasket_recursive(k0, k2, k3, z0, z2, z3, 0, [0, 255, 0])

    # 3. Промежуток (C0, C3, C1)
    apollonian_gasket_recursive(k0, k3, k1, z0, z3, z1, 0, [0, 0, 255])

    # 4. Промежуток (C1, C2, C3) - центральная окружность
    # Здесь k0 = k1 = k2 = 3.0 (хотя они не равны, но это для простоты)
    # В этом случае нужно найти две окружности: одна в центре и одна снаружи.
    # Мы начнем с простой, заполняющей центральную дыру.
    k_center, _ = find_new_curvatures(k1, k2, k3)

    # Чтобы избежать сложных вычислений, мы просто запустим рекурсию с тройками
    # (C1, C2, C3), где C4 - уже найденная центральная окружность.

    # Запускаем рекурсию только для трех внешних промежутков,
    # этого достаточно для демонстрации рекурсивного метода.

    # === СОХРАНЕНИЕ РЕЗУЛЬТАТА ===
    img = Image.fromarray(PIXEL_GRID, 'RGB')
    img.save("apollonian_gasket.png")
    print(f"Построение завершено. Изображение сохранено как 'apollonian_gasket.png' с глубиной {MAX_DEPTH}.")


if __name__ == "__main__":
    main()