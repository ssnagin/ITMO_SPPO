# Лабораторная работа #3

Для отношений, полученных при построении предметной области из лабораторной работы №1, выполните следующие действия:

- Опишите функциональные зависимости для отношений полученной схемы (минимальное множество);
- Приведите отношения в 3NF (как минимум). Постройте схему на основеNF (как минимум). 
- Опишите изменения в функциональных зависимостях, произошедшие после преобразования в 3NF (как минимум). Постройте схему на основеNF;
- Преобразуйте отношения в BCNF. Докажите, что полученные отношения представлены в BCNF. Если ваша схема находится уже в BCNF, докажите это;
- Какие денормализации будут полезны для вашей схемы? Приведите подробное описание.

Придумайте триггер и связанную с ним функцию, относящиеся к вашей предметной области, согласуйте их с преподавателем и реализуйте на языке PL/pgSQL.

Отчёт по лабораторной работе должен содержать:

1. Текст задания.
2. Исходная, нормализованная и денормализованная модели.
3. Ответы на вопросы, представленные в задании.
4. Функция и триггер на языке PL/pgSQL
5. Выводы по работе.

Темы для подготовки к защите лабораторной работы:

1. Нормализация. Формы
2. Функциональные зависимости. Виды
3. Денормализация
4. Язык PL/pgSQL

## Теория

### Функциональные зависимости

[Здесь](https://habr.com/ru/companies/JetBrains-education/articles/473882/) отличная теория по этому

### Триггеры и правила

PostgreSQL предоставляет триггеры и правила, позволяющие автоматически
выполнять некоторые действия при возникновении событий, например вы-
полнении команд INSERT, UPDATE или DELETE. Для команды SELECT триггеры и пра-
вила не определяются, за исключением правила RETURN, которое используется
во внутренней реализации представлений.

С точки зрения функциональности триггеры обладают большей общностью,
чем правила, и позволяют проще реализовать сложные действия. Но в ряде
случаев необходимую функциональность можно получить с помощью как
триггеров, так и правил. По производительности правила быстрее, зато триг-
геры проще и совместимы с другими РСУБД (правила – специфическое рас-
ширение PostgreSQL).

#### Правила

Создание правила означает либо модификацию правила по умолчанию, либо
создание нового правила для определенного действия с определенной табли-
цей или представлением. 

Иными словами, правило для действия при вставке может либо изменить поведение вставки, либо создать для нее новое действие. Следует иметь в виду, что вся система правил основана на макросах языка C Поэтому можно получить странные результаты при использовании правил совместно с волатильными функциями типа random() и функциями последовательностей типа nextval().

В следующем примере демонстрируются подвохи правил. Допустим, требуется организовать аудит действий с таблицей car. Для этого создадим новую таблицу car_log, в которой будут храниться все действия с таблицей car: обновления, удаления и вставки. Сделать это можно с помощью правил:

```sql
CREATE TABLE car_log (LIKE car);
ALTER TABLE car_log
	ADD COLUMN car_log_action varchar (1) NOT NULL,
	ADD COLUMN car_log_time TIMESTAMP WITH TIME ZONE NOT NULL;
CREATE RULE car_log AS ON INSERT TO car DO ALSO
	INSERT INTO car_log (car_id, car_model_id, number_of_owners,
		registration_number, number_of_doors, manufacture_year,car_log_action,
		car_log_time)
	VALUES (new.car_id, new.car_model_id,new.number_of_owners,
		new.registration_number, new.number_of_doors, new.manufacture_year,'I',
	now());
```

Здесь мы создаем таблицу car_log, структурно аналогичную таблице car, но
имеющую два дополнительных атрибута для протоколирования действий: тип
операции (в примере ‘I’ означает вставку) и время действия. Мы также создаем
правило для таблицы car, сводящееся к вставке в car_log копии записи, встав-
ленной в car. Для тестирования вставим одну запись:

```sql
INSERT INTO car (car_id, car_model_id, number_of_owners,
registration_number, number_of_doors, manufacture_year) VALUES (100000, 2,
2, 'x', 3, 2017);
```

Проверим содержимое таблицы car_log:

```sql
car_portal=> SELECT to_json(car) FROM car where registration_number ='x';
to_json
---------------------------------------------------------------------------
-------------------------------------------------------------------------
{"car_id":100000,"number_of_owners":2,"registration_number":"x","manufactur
e_year":2017,"number_of_doors":3,"car_model_id":2,"mileage":null}
(1 row)
car_portal=> SELECT to_json(car_log) FROM car_log where registration_number
='x';
to_json
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------
{"car_id":100000,"number_of_owners":2,"registration_number":"x","manufactur
e_year":2017,"number_of_doors":3,"car_model_id":2,"mileage":null,"car_log_a
ction":"I","car_log_time":"2017-11-20T20:08:50.107895+01:00"}
(1 row)
```

Как видим, все идет по плану. В таблицу car вставлена одна запись, и точно
такая же запись вставлена в таблицу car_log. Но, как уже отмечалось, систе-
ма правил основана на макросах, и это может приводить к некоторым проб­
лемам. Одна из них возникает, если мы захотим использовать значение по
умолчанию:

```sql
INSERT INTO car (car_id, car_model_id, number_of_owners,
registration_number, number_of_doors, manufacture_year)
VALUES (default, 2, 2, 'y', 3, 2017);
```

Посмотрим, как изменилось содержимое обеих таблиц:

```sql
car_portal=> SELECT to_json(car) FROM car where registration_number ='y';
to_json
--------------------------------------------------------------------------
----------------------------------------------------------------
{"car_id":230,"number_of_owners":2,"registration_number":"y","manufacture_y
ear":2017,"number_of_doors":3,"car_model_id":2,"mileage":null}
(1 row)
car_portal=> SELECT to_json(car_log) FROM car_log where registration_number
='y';
to_json
--------------------------------------------------------------------------
--------------------------------------------------------------------------
------------------------------------------------------------
{"car_id":231,"number_of_owners":2,"registration_number":"y","manufacture_y
ear":2017,"number_of_doors":3,"car_model_id":2,"mileage":null,"car_log_acti
on":"I","car_log_time":"2017-11-20T20:14:49.820841+01:00"}
(1 row)
```

Обратите внимание, что значение столбца car_id в таблице car на единицу
меньше, чем в car_log. Ключевое слово DEFAULT означает, что car_id нужно присвоить значение по умолчанию, которое в данном случае равно nextval('car_
car_id_seq'::regclass).

Правила могут быть условными, т. е. действие переопределяется при выпол-
нении некоторого условия. Однако невозможно задать условные правила для
команд INSERT, UPDATE и DELETE, применяемых к представлениям, если отсутствует безусловное правило. Для решения этой проблемы можно создать фиктивное безусловное правило. Правила над представлениями – один из способов реализовать обновляемые представления.

### Триггеры

PostgreSQL запускает триггерную функцию, когда возникает некоторое событие в таблице, представлении или внешней таблице. Триггер выполняется, когда пользователь пытается модифицировать данные с помощью любой команды языка манипулирования данными (DML), а именно INSERT, UPDATE, DELETE или TRUNCATE. Ниже приведен синтаксис команды создания триггера:

```sql
CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER _`name`_ { BEFORE | AFTER | INSTEAD OF } { _`event`_ [ OR ... ] }
    ON _`table_name`_
    [ FROM _`referenced_table_name`_ ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] _`transition_relation_name`_ } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( _`condition`_ ) ]
    EXECUTE { FUNCTION | PROCEDURE } _`function_name`_ ( _`arguments`_ )
```

where _`event`_ can be one of:

```
    INSERT
    UPDATE [ OF _`column_name`_ [, ... ] ]
    DELETE
    TRUNCATE
```

The following table summarizes which types of triggers may be used on tables, views, and foreign tables:
   
|     When     |           Event            |         Row-level         |          Statement-level          | Description                                                                                                                                                                                                      |
| :----------: | :------------------------: | :-----------------------: | :-------------------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   `BEFORE`   | `INSERT`/`UPDATE`/`DELETE` | Tables and foreign tables | Tables, views, and foreign tables | Триггер запускается перед проверкой ограничений и выполнением операции. Полезно для проверки ограничений, охватывающих несколько таблиц, которые невозможно смоделировать как ограничения ссылочной целостности. |
|   `AFTER`    | `INSERT`/`UPDATE`/`DELETE` | Tables and foreign tables | Tables, views, and foreign tables | Запускается после выполнения операции. Полезно для каскадного применения изменений к другим таблицам. Примером может служить аудит данных.                                                                       |
| `INSTEAD OF` | `INSERT`/`UPDATE`/`DELETE` |           Views           |                 —                 | Применяется к представлениям, чтобы сделать их обновляе-<br>мыми                                                                                                                                                 |
![](Pasted%20image%2020250428181438.png)

Если в команде создания триггера присутствует фраза FOR EACH ROW, то триггерная функция вызывается для каждой строки, затронутой операцией. Триггер
с фразой FOR EACH STATEMENT выполняется один раз для операции. Если присутствует условие WHEN, то триггер применяется только к строкам, удовлетворяющим условию.

Наконец, триггер может быть помечен ключевым словом CONSTRAINT, чтобы указать, в какой момент он выполняется: в конце команды или в конце транз­акции. Триггер-ограничение может быть только типа AFTER или FOR EACH ROW, а время его cрабатывания определяется следующими ключевыми словами.
- **DEFERABLE**: срабатывание триггера откладывается до конца транзакции
- **INITIALLY DEFERRED**: определяет время выполнения триггера и означает, что триггер выполняется в конце транзакции. Триггер должен быть определен как **DEFERRABLE**
- **NOT DEFERRABLE**: это поведение по умолчанию – триггер срабатывает после каждой команды;
- **INITIALLY IMMEDIATE**: определяет время выполнения триггера и означает,
что триггер выполняется после каждой команды. Триггер должен быть
определен как **DEFERRABLE**.

> Имя триггера обычно отражает временной контекст его выполнения.

Опции времени срабатывания – DEFERRABLE, INITIALLY DEFERRED, NOT DEFERRABLE,
INITIALLY IMMEDIATE – применимы и к триггерам-ограничениям. Они очень по-
лезны в случаях, когда PostgreSQL взаимодействует с внешними системами,
например memcached. Предположим, к примеру, что над таблицей определен
триггер, и эта таблица кешируется: при каждом обновлении таблицы обнов-
ляется также и кеш. Поскольку система кеширования не транзакционная, мы
можем отложить обновление до момента завершения транзакции, когда будет
гарантирована согласованность данных.

