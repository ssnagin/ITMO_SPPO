## Лабораторная работа #2

### Задание

По варианту, выданному преподавателем, составить и выполнить запросы к [базе данных "Учебный процесс"](https://se.ifmo.ru/documents/10180/733702/%D0%91%D0%94+%D0%A3%D1%87%D0%B5%D0%B1%D0%BD%D1%8B%D0%B9+%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81.pdf/2eae3fcd-ea34-4496-924b-6ee4e889a9e5).

Команда для подключения к базе данных ucheb:

_psql -h pg -d ucheb_

#### Отчёт по лабораторной работе должен содержать:

1. Текст задания.
2. Реализацию запросов на SQL.
3. Выводы по работе.

#### Темы для подготовки к защите лабораторной работы:

1. SQL
2. Соединение таблиц
3. Подзапросы
4. Представления
5. Последовательности

#### [Решение тут](SOLUTION.md)

## Теория

### SQL

**Структурированный язык запросов** (SQL) используется для описания структуры базы данных, манипулирования данными в базе и предъявления запросов. Он также используется для определения и изменения структуры базы, т. е. для реа­лизации модели данных.

SQL состоит из трех частей:
- язык определения данных (DDL);
- язык манипулирования данными (DML);
- язык управления данными (DCL).

Язык DDL нужен для создания и управления структурой данных, язык DML – для управления самими данными, а язык DCL – для управления доступом к данным. Обычно структура данных определяется только один раз и изменяется сравнительно редко. Но вставка, изменение и выборка данных производятся постоянно. Поэтому DML используется чаще, чем DDL.

В отличие от многих других языков, SQL – не императивный язык программирования. Точнее, на нем невозможно подробно описать алгоритм обработки данных. Поэтому может сложиться впечатление, будто мы не способны управлять данными. На императивном языке программист описывает работу с данными на очень детальном уровне: откуда взять данные и как это сделать, как обойти массив записей, когда и как обработать их. Если необходимо обработать данные из нескольких источников, то программист должен реализовать связи между ними на уровне приложения, а не в самой базе.

Но SQL – декларативный язык. Иными словами, чтобы получить тот же результат на других языках, нужно написать целую историю. А на SQL разработчик пишет только предложение, выражающее суть, а детали оставляет базе данных. В SQL-команде определяем формат, в котором мы хотим получить данные, указываем, в каких таблицах данные хранятся, и формулируем правила их обработки. Все необходимые операции, их точный порядок и алгоритмы обработки данных определяет база, а разработчику до этого не должно быть дела.

Еще одна отличительная особенность SQL – наличие стандарта языка. Это
означает, что все современные реляционные базы данных поддерживают SQL.
Конечно, в каждой базе есть собственный диалект SQL с дополнительными
возможностями, но ядро языка везде одно и то же. 

Кстати, в самом начале пути база postgres не поддерживала SQL. Он был добавлен лишь в 1994 году, и, чтобы отметить этот факт, база была переименована в PostgreSQL.

#### Пример запроса

```sql
SELECT поля FROM таблицы WHERE условия...;
```

Вместо WHERE может быть:

- **WHERE** - для определения, какие строки должны быть выбраны или включены в **GROUP BY**
- **GROUP BY** - для объединения строк с общими значениями в элементы меньшего набора строк
- **HAVING** - для определения, какие строки после **GROUP BY** должны быть выбраны
- **ORDER BY** -  сортировка результирующего набора данных

#### Логические операторы

- AND
- NOT
- OR
- true, false, NULL

AND и OR коммутативны

#### Предикаты сравнения

| Оператор                     | Описание                                         |
| ---------------------------- | ------------------------------------------------ |
| `a` BETWEEN `x` AND `y`      | `a` между `x` и `y` (включительно)               |
| `a` NOT BETWEEN `x` AND `y`  | `a` не между `x` и `y`                           |
| `a` IS DISTINCT FROM `b`     | Как `<>`, но `NULL` считается отличным от `NULL` |
| `a` IS NOT DISTINCT FROM `b` | Как `=`, но `NULL` считается равным `NULL`       |
| `выражение` IS NULL          | Проверка на `NULL`                               |
| `выражение` IS NOT NULL      | Проверка на не-`NULL`                            |

#### Поиск по шаблону: LIKE (поиск в строке)

```sql
строка LIKE шаблон
строка NOT LIKE шаблон
```

Выражение LIKE возврещает TRUE, если строка соответствует заданному шаблону

#### **SIMILAR TO (регулярные выражения SQL-стандарта)**

```sql
строка SIMILAR TO шаблон
строка NOT SIMILAR TO шаблон
```

Выражение SIMILAR TO возвращает true, если строка соответствует заданному шаблону. Поддерживает больше видов регулярных выражений, чем LIKE

##### **Когда что использовать?**

| Оператор     | Когда применять?                        |
| ------------ | --------------------------------------- |
| `LIKE`       | Простые шаблоны (`%test%`, `user_123`). |
| `SIMILAR TO` | Сложные шаблоны (микс `LIKE` и regex).  |
| `~` / `~*`   | Полноценные регулярные выражения.       |

**Совет:** Для сложных поисков (например, валидации email) используйте `~`, для простых — `LIKE`.

#### GROUP BY, группировка и агрегирование

Фраза **GROUP BY** служит для группировки. Под группировкой понимается разбиение всего множества входных записей на несколько групп, имея в виду
получение одной результирующей строки для каждой группы. Группировка
производится по списку выражений. Все строки с одной и той же комбинацией значений группирующих выражений объединяются в одну группу. Таким
образом, группы определяются значениями выражений, указанных во фразе
GROUP BY. Обычно имеет смысл включать эти выражения в список выборки, чтобы было видно, к какой группе относится каждая результирующая строка.

Сгруппируем данные по марке и модели автомобиля и выберем группы:

![](Pasted%20image%2020250401151804.png)

Здесь мы видим список всех моделей, представленных в таблице car. Каждая
результирующая запись представляет группу записей исходных таблиц, отно-
сящихся к одной и той же модели. На самом деле этот запрос дает такой же результат, как SELECT DISTINCT make, model... без GROUP BY, но логика их выполнения различна. DISTINCT удаляет дубликаты, а GROUP BY объединяет дубликаты в одну группу.

От простой группировки строк толку мало. Обычно требуется произвести
некоторые вычисления над группами. Так, было бы интересно знать, сколько
автомобилей каждой модели имеется в системе. Это делается с помощью **агрегирования**, т. е. такого вычисления над группами записей, в результате которого для каждой группы возвращается одно значение. Для этой цели имеются специальные агрегатные функции, указываемые в списке выборки. 

Чтобы получить количество автомобилей, воспользуемся функцией count:

![](Pasted%20image%2020250401151907.png)

В PostgreSQL имеется несколько агрегатных функций. Чаще всего использу-
ются count, sum, max, min и avg, которые вычисляют, соответственно, количество записей в группе, сумму числовых выражений по всем записям, наибольшее, наименьшее и среднее значения выражения. Существуют и другие агрегатные функции, например corr вычисляет коэффициент корреляции двух аргументов, stddev – стандартное отклонение, string_agg – конкатенацию строковых значений и т. д.

Для агрегирования записи группируются, т. е. несколько записей отобража-
ется в одну. Поэтому в списке выборки не может быть ничего, кроме агрегат-
ных функций и выражений, вошедших в список GROUP BY, в противном случае
возникнет ошибка:

![](Pasted%20image%2020250401151945.png)

Джуба, Волков: "Изучаем PostgresSQL", стр. 153
#### Кратко про GROUP BY для маленьких и глупеньких (я)

**GROUP BY** — это как сортировка вещей по коробкам

Представь, что у тебя есть куча носков (данные в таблице), и ты хочешь разложить их по цветам.

##### **Без GROUP BY:**

Ты просто видишь все носки вперемешку:

```sql
Красный  
Синий  
Красный  
Зеленый  
Синий  
Синий
```

##### С GROUP BY:

Ты группируешь носки по цветам и считаешь, сколько каждого:

```sql
SELECT цвет, COUNT(*) 
FROM носки 
GROUP BY цвет;
```

```
ЦВЕТ     КОЛ-ВО
------------
Красный | 2  
Синий   | 3  
Зеленый | 1  
```

### Соединение таблиц

![](img/joins.png)

#### INNER JOIN (Внутреннее соединение)
Возвращает строки, где есть соответствие в обеих таблицах.

```sql
SELECT a.*, b.*
FROM table_a a
INNER JOIN table_b b ON a.id = b.a_id;
```

#### LEFT JOIN (LEFT OUTER JOIN)

Возвращает все строки из левой таблицы и соответствующие из правой (или NULL, если соответствий нет).

```sql
SELECT a.*, b.*
FROM table_a a
LEFT JOIN table_b b ON a.id = b.a_id;
```

#### RIGHT JOIN (RIGHT OUTER JOIN)

Возвращает все строки из правой таблицы и соответствующие из левой (или NULL, если соответствий нет).

```sql
SELECT a.*, b.*
FROM table_a a
RIGHT JOIN table_b b ON a.id = b.a_id;
```

#### FULL JOIN (FULL OUTER JOIN)

Возвращает все строки из обеих таблиц, с NULL там, где нет соответствий.

```sql
SELECT a.*, b.*
FROM table_a a
FULL JOIN table_b b ON a.id = b.a_id;
```

#### CROSS JOIN

Декартово произведение - каждая строка из первой таблицы соединяется с каждой строкой из второй.

```sql
SELECT a.*, b.*
FROM table_a a
CROSS JOIN table_b b;
```

#### NATURAL JOIN

Соединяет таблицы по столбцам с одинаковыми именами (не рекомендуется).

```sql
SELECT *
FROM table_a
NATURAL JOIN table_b;
```

#### SELF JOIN

Соединение таблицы с самой собой. 

Это метод сравнения записей внутри одной и той же таблицы, который создаёт эффект «двойного зеркала». Это можно сравнить с добавлением своего же портрета в групповое изображение.

```sql
SELECT
    e1.name AS 'Сотрудник',
    e2.name AS 'Менеджер'
FROM
    employees e1
JOIN
    employees e2 ON e1.manager_id = e2.id;
```

#### JOIN нескольких таблиц

```sql
SELECT a.*, b.*, c.*
FROM table_a a
JOIN table_b b ON a.id = b.a_id
JOIN table_c c ON b.id = c.b_id;
```

### Подзапросы

Вложенный подзапрос (**SUBQUERY**) — это предложение **SELECT**, заключенное в круглые скобки и вложенное в **WHERE** (**HAVING**)-фразу другого предложения **SELECT** или иных предложений, использующих **WHERE**-фразу. Вложенный подзапрос может содержать в своей WHERE (**HAVING**)-фразе другой вложенный подзапрос и т. д. Нетрудно догадаться, что вложенный подзапрос создан для того, чтобы при отборе строк таблицы, сформированной основным запросом, можно было использовать данные из других таблиц (например, при отборе блюд для меню использовать данные о наличии продуктов в кладовой пансионата).

Существуют простые и коррелированные вложенные подзапросы. Они включаются в WHERE (HAVING)-фразу с помощью условий IN, EXISTS или одного из условий сравнения ( = | <> | < | <= | > | >= ). Простые вложенные подзапросы обрабатываются системой "снизу вверх". Первым обрабатывается вложенный подзапрос самого нижнего уровня. Множество значений, полученное в результате его выполнения, используется при реализации подзапроса более высокого уровня и т. д.

Запросы с коррелированными вложенными подзапросами обрабатываются системой в обратном порядке. Сначала выбирается первая строка рабочей таблицы, сформированной основным запросом, и из нее выбираются значения тех столбцов, которые используются во вложенном подзапросе (вложенных подзапросах). Если эти значения удовлетворяют условиям вложенного подзапроса, то выбранная строка включается в результат. Затем выбирается вторая строка и т. д., пока в результат не будут включены все строки, удовлетворяющие вложенному подзапросу (последовательности вложенных подзапросов).

Следует отметить, что SQL обладает большой избыточностью в том смысле, что он часто предоставляет несколько различных способов формулировки одного и того же запроса. Поэтому во многих примерах данной главы будут использованы уже знакомые нам по предыдущей главе концептуальные формулировки запросов. И несмотря на то, что часть из них успешнее реализуется с помощью соединений, здесь все же будут приведены их варианты с использованием вложенных подзапросов. Это связано с необходимостью детального знакомства с созданием и принципом выполнения вложенных подзапросов, так как существует немало задач (особенно на удаление и изменение данных), которые не могут быть реализованы другим способом. Кроме того, разные формулировки одного и того же запроса требуют для своего выполнения различные ресурсы памяти и могут значительно отличаться по времени реализации в разных СУБД.

### Представления

Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.

Представления иногда называют «виртуальными таблицами». Такое название связано с тем, что представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему. Если данные изменены в базовой таблице, то пользователь получит актуальные данные при обращении к представлению, использующему данную таблицу; кэширования результатов выборки из таблицы при работе представлений не производится. При этом, механизм кэширования запросов (query cache) работает на уровне запросов пользователя безотносительно к тому, обращается ли пользователь к таблицам или представлениям.

#### Преимущества использования представлений:

1. Дает возможность гибкой настройки прав доступа к данным за счет того, что права даются не на таблицу, а на представление. Это очень удобно в случае если пользователю нужно дать права на отдельные строки таблицы или возможность получения не самих данных, а результата каких-то действий над ними.
2. Позволяет разделить логику хранения данных и программного обеспечения. Можно менять структуру данных, не затрагивая программный код, нужно лишь создать представления, аналогичные таблицам, к которым раньше обращались приложения. Это очень удобно когда нет возможности изменить программный код или к одной базе данных обращаются несколько приложений с различными требованиями к структуре данных.
3. Удобство в использовании за счет автоматического выполнения таких действий как доступ к определенной части строк и/или столбцов, получение данных из нескольких таблиц и их преобразование с помощью различных функций.

```sql
CREATE [OR REPLACE]   [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]   VIEW view_name [(column_list)]   AS select_statement   [WITH [CASCADED | LOCAL] CHECK OPTION]
```

### Последовательности

Последовательность (sequence) генерирует уникальные порядковые номера, которые могут использоваться как значения числовых столбцов таблиц базы данных. Последовательности упрощают решение многих задач, когда требуется генерация уникальных числовых значений для строк одной или нескольких таблиц.

```sql
CREATE SEQUENCE [схема.]имя_последовательности
[INCREMENT BY целое_число]
[START WITH целое_число];
```

где `схема` — это схема, в которой создается последовательность (если она опущена, то последовательность создается в схеме текущего пользователя)

`имя_последовательности` — имя создаваемой последовательности.

`START WITH` определяет первый генерируемый номер последовательности (по умолчанию он равен 1).

Для выбора следующего уникального значения последовательности используется псевдостолбец `имя_последовательности.NEXTVAL`, а для текущего — `имя_последовательности.CURRVAL`.

Полный набор команд:

```sql
CREATE [ { TEMPORARY | TEMP } | UNLOGGED ] SEQUENCE [ IF NOT EXISTS ] _`name`_
    [ AS _`data_type`_ ]
    [ INCREMENT [ BY ] _`increment`_ ]
    [ MINVALUE _`minvalue`_ | NO MINVALUE ] [ MAXVALUE _`maxvalue`_ | NO MAXVALUE ]
    [ START [ WITH ] _`start`_ ] [ CACHE _`cache`_ ] [ [ NO ] CYCLE ]
    [ OWNED BY { _`table_name`_._`column_name`_ | NONE } ]
```

