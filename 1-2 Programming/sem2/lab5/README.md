
см. https://github.com/ssnagin/java-sem2-lab5.git

# Теория по Лабораторной работе №5

По большей части это пересказ даух книг (см. источники).
## Коллекции

*Коллекции* — это классы для сохранения, получения, манипулирования
множеством объектов.

![](Pasted%20image%2020250306190506.png)

Основополагающим для классов коллекций в библиотеке Java является интерфейс
*Collection*. В его состав входят два основных метода:

```java
public interface Collection<E>
{
	boolean add(E element);
	Iterator<E> iterator();
}
```

Метод `add()` добавляет элемент в коллекцию. Он возвращает логическое значение true, если добавление элемента в действительности изменило коллекцию, а если коллекция осталась без изменения — логическое значение false. Так, если по­пытаться добавить объект в коллекцию, где такой объект уже имеется, вызов метода add () не даст желаемого результата, поскольку коллекция не допускает дублирова­ние объектов. А метод `iterator()` возвращает объект класса, реализующего интер­фейс Iterator. Объект итератора можно выбрать для обращения ко всем элементам коллекции по очереди. Об этом чуть ниже.

**Collections** — класс, состоящий из статических методов, осуществляющих
различные служебные операции над коллекциями

| Метод                                                 | Описание                                                                                                                                                                                                                                               |
| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `min(Collection)`                                     | Вернуть минимальный элемент коллекции.                                                                                                                                                                                                                 |
| `max(Collection)`                                     | Вернуть максимальный элемент коллекции.                                                                                                                                                                                                                |
| `rotate(List list, int distance)`                     | Циклически повернуть список на указанное число элементов.                                                                                                                                                                                              |
| `replaceAll(List list, Object oldVal, Object newVal)` | Заменить в списке все найденные экземпляры на указанный.                                                                                                                                                                                               |
| `indexOfSubList(List source, List target)`            | Возвращает индекс первого субсписка source, который эквивалентен target.                                                                                                                                                                               |
| `lastIndexOfSubList(List source, List target)`        | Возвращает индекс последнего субсписка source, который эквивалентен target.                                                                                                                                                                            |
| `swap(List, int, int)`                                | Обменивает элементы в указанных позициях списка.                                                                                                                                                                                                       |
| `unmodifiableCollection(Collection c)`                | Создает неизменяемое представление указанной коллекции c. Есть аналогичные методы для отдельных видов коллекций: List, Set, Map, а также Sorted и Navigable подвидов множеств и отображений.                                                           |
| `synchronizedCollection(Collection c)`                | Создает потокобезопасное представление указанной коллекции c. Есть аналогичные методы для отдельных видов коллекций: List, Set, Map, а также Sorted и Navigable подвидов множеств и отображений.                                                       |
| `checkedCollection(Collection<E> c, Class<E> type)`   | Создает типобезопасное представление указанной коллекции c, в которое нельзя добавить тип, отличный от type. Есть аналогичные методы для отдельных видов коллекций: List, Queue, Set, Map, а также Sorted и Navigable подвидов множеств и отображений. |
| `Set<T> singleton(T o);`                              | Возвращает неизменяемое множество, содержащее только заданный объект.                                                                                                                                                                                  |
| `List<T> singletonList(T o);`                         | Возвращает неизменяемый список, содержащий только заданный объект.                                                                                                                                                                                     |
| `Map<K,V> singletonMap(K key, V value);`              | Возвращает неизменяемое отображение, содержащее только объект с заданным ключом и значением.                                                                                                                                                           |
| `emptyList()`                                         | Возвращает пустой список. Есть аналогичные методы для других видов коллекций: Set, Map, а также Sorted и Navigable подвидов множеств и отображений.                                                                                                    |
| `<T> List<T> nCopies(int n, T o)`                     | Создает неизменяемый List, содержащий n копий заданного объекта.                                                                                                                                                                                       |
| `sort(list)`                                          | Сортировать список, используя merge sort алгоритм, с гарантированной скоростью О(n*log n).                                                                                                                                                             |
| `binarySearch(list, Object)`                          | Бинарный поиск элементов в списке.                                                                                                                                                                                                                     |
| `reverse(list)`                                       | Изменить порядок элементов в списке на противоположный.                                                                                                                                                                                                |
| `shuffle(list)`                                       | Случайно перемешать элементы.                                                                                                                                                                                                                          |
| `fill(list, Object)`                                  | Заменить каждый элемент заданным.                                                                                                                                                                                                                      |
| `copy(list dest, List src)`                           | Скопировать список src в dest.                                                                                                                                                                                                                         |
| `frequency(Collection, object)`                       | Возвращает количество элементов в коллекции, равных заданному объекту.                                                                                                                                                                                 |
| `reverseOrder()`                                      | Возвращает компаратор для обратной сортировки элементов.                                                                                                                                                                                               |
| `list(Enumeration<T> e)`                              | Возвращает Enumeration в виде ArrayList.                                                                                                                                                                                                               |
| `disjoint(Collection, Collection)`                    | Возвращает true, если коллекции не содержат общих элементов.                                                                                                                                                                                           |
| `addAll(Collection<? super T>, T[])`                  | Добавить все элементы из массива в коллекцию.                                                                                                                                                                                                          |
| `newSetFromMap(Map)`                                  | Создает новое множество из отображения.                                                                                                                                                                                                                |
| `asLifoQueue(Deque d)`                                | Создает представление типа стека из двусторонней очереди d с методами push() и pop().                                                                                                                                                                  |

### Итераторы

В состав интерфейса Iterator входят три метода:

```java
public interface Iterator<E>
{
	Е next();
	boolean hasNext();
	void remove();
}
```

Многократно вызывая метод next(), можно обратиться к каждому элементу кол­
лекции по очереди. Но если будет достигнут конец коллекции, то метод next () сге­
нерирует исключение типа NoSuchElementException. Поэтому перед вызовом ме­
тода next() следует вызывать метод hasNext(). Этот метод возвращает логическое
значение true, если у объекта итератора все еще имеются объекты, к которым можно
обратиться. Если же требуется перебрать все элементы коллекции, то следует запро­
сить итератор, продолжая вызывать метод next() до тех пор, пока метод hasNext()
возвращает логическое значение true. В приведенном ниже примере показано, как
все это реализуется непосредственно в коде.

```java
Collection<String> с = . . .;
Iterator<String> iter = с.iterator();
while (iter.hasNext())
{
	String element = iter.nextO;
	сделать что-нибудь с элементом element
}
```


Тот же самый код можно написать более компактно, организовав цикл в стиле
for each следующим образом:

```java
for (String element : с)
{
сделать что-нибудь с элементом element
}
```

Компилятор просто преобразует цикл в стиле for each в цикл с итератором.
Цикл в стиле for each подходит для любых объектов, класс которых реализует ин­
терфейс Iterable со следующим единственным методом:

```java
public interface Iterable<E>
{
Iterator<E> iterator();
}
```

Интерфейс Collection расширяет интерфейс Iterable. Поэтому цикл в стиле
for each подходит для обращения к элементам любой коллекции из стандартной
библиотеки.

Порядок, в котором перебираются элементы, зависит от типа коллекции. Так,
если осуществляется перебор элементов коллекции типа ArrayList, итератор начи­
нает его с нулевого индекса, увеличивая последнее значение на каждом шаге итера­
ции. Но если осуществляется перебор элементов коллекции типа Hash Set, то они
получаются в совершенно случайном порядке. Можно быть уверенным лишь в том,
что за время итерации будут перебраны все элементы коллекции, хотя нельзя сде­
лать никаких предположений относительно порядка их следования. Обычно это не
особенно важно, потому что порядок не имеет значения при таких вычислениях, как,
например, подсчет суммы или количества совпадений.

Имеется принципиальное отличие между итераторами из библиотеки коллекций
в Java и других библиотек. В традиционных библиотеках коллекций, как, например,
Standard Template Library в C++, итераторы моделируются по индексам массива. Имея
такой итератор, можно найти элемент, находящийся на данной позиции в массиве,
подобно тому, как находится элемент массива `а[i]` , если имеется индекс i. Незави­
симо от способа поиска элементов коллекции, итератор можно передвинуть на сле­
дующую позицию. Эта операция аналогична приращению индекса i++ без поиска.
Но итераторы в Java действуют иначе. Поиск элементов в коллекции и изменение их
позиции тесно взаимосвязаны. Единственный способ найти элемент — вызвать метод
next (), а в ходе поиска происходит переход на следующую позицию.

Напротив, итераторы в Java следует представлять себе так, как будто они находят­
ся между элементами коллекции. Когда вызывается метод next (), итератор переска­
кивает следующий элемент и возвращает ссылку на тот элемент, который он только
что прошел.

Метод remove () из интерфейса Iterator удаляет элемент, который был возвра­
щен при последнем вызове метода next (). Во многих случаях это имеет смысл, по­
скольку нужно проанализировать элемент, прежде чем решаться на его удаление. Но
если требуется удалить элемент, находящийся на определенной позиции, то сначала
придется его пройти. В приведенном ниже примере показано, как удалить первый
элемент из коллекции символьных строк.

```java
Iterator<String> it = с. iterator();
it.next(); // пройти первый элемент коллекции
it.remove(); / / а теперь удалить его
```

![](Pasted%20image%2020250306225358.png)

Но важнее то, что между вызовами методов next () и remove () существует опре­
деленная связь. В частности, вызывать метод remove () не разрешается, если перед
ним не был вызван метод next (). Если же попытаться сделать это, будет сгенери­
ровано исключение типа IllegalStateException. А если из коллекции требуется
удалить два соседних элемента, то нельзя просто вызвать метод remove () два раза
подряд, как показано ниже.

```java
it.remove();
it.remove(); // ОШИБКА!
```

Вместо этого нужно сначала вызвать метод next () , чтобы пройти удаляемый эле­
мент, а затем удалить его, как следует из приведенного ниже примера кода.

```java
it.remove();
it.next();
it.remove(); // Допустимо!
```

### Сортировка элементов коллекции

Сортировка элементов коллекции в интерфейсе SortedMap и аналогичных,
производится при помощи естественного порядка сортировки, определяемого в
элементе коллекции, либо при помощи интерфейса Comparator.

| Естественный порядок сортировки (natural sort order) — естественный и<br>реализованный по умолчанию (реализацией метода compareTo интерфейса<br>java.lang.Comparable) способ сравнения двух экземпляров одного класса. |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

```java
int compareTo(E other)
``` 

— сравнивает this объект с other и возвращает
отрицательное значение если `this < other`, `0` — если они равны и
положительное значение если` this > other`. 

Для класса Byte данный метод реализуется следующим образом:

```java
public int compareTo(Byte anotherByte) {
	return this.value - anotherByte.value;
}
```

`java.util.Comparator` — содержит два метода:
• `int compare(T o1, T o2)` — сравнение, аналогичное `compareTo`
• `boolean equals(Object obj)` — `true` если `оbj` — это `Comparator`, и у него такой же принцип сравнения.

## Источники
1. Гаврилов А.В., Клименков С.В., Николаев В.В., Харитонова А.Е., Цопа Е.А., Программирование на языке Java: конспект лекций– СПб: Университет ИТМО. — 130 с.
2. Хорстманн, Кей С. Java. Библиотека профессионала, том 1. Основы. 10-е и зд .: Пер. с англ. — М .: ООО "И.Д. Вильямс", 2016. — 864 с . : ил. — Парал. тит. англ.
3. Java 8. Полное руководство; 9-е изд.: Пер. с англ. - М. : ООО "И.Д. Вильяме". - 1 376 с. : ил. - Парал. тит. англ. ISBN 978-5-8459-1918-2 